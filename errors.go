package oops

import (
	"encoding/json"
	"fmt"
	"reflect"
	"runtime"
	"strings"
)

type (
	Frame runtime.Frame
)

func (f Frame) MarshalJSON() ([]byte, error) {
	type alias struct {
		Function string
		File     string
		Line     int
	}
	a := alias{
		Function: f.Function,
		File:     f.File,
		Line:     f.Line,
	}
	return json.Marshal(a)
}

type AlreadyExistsError struct {
	oopsError
}

func (a AlreadyExistsError) Inject(msg string, err error) error {
	t := reflect.TypeOf(a).String()
	a.oopsError = a.oopsError.Inject(msg, t, err)
	return &a
}

type InternalError struct {
	oopsError
}

func (i InternalError) Inject(msg string, err error) error {
	t := reflect.TypeOf(i).String()
	i.oopsError = i.oopsError.Inject(msg, t, err)
	return &i
}

type InputError struct {
	oopsError
}

func (i InputError) Inject(msg string, err error) error {
	t := reflect.TypeOf(i).String()
	i.oopsError = i.oopsError.Inject(msg, t, err)
	return &i
}

type NotFoundError struct {
	oopsError
}

func (n NotFoundError) Inject(msg string, err error) error {
	t := reflect.TypeOf(n).String()
	n.oopsError = n.oopsError.Inject(msg, t, err)
	return &n
}

type NotAuthorizedError struct {
	oopsError
}

func (n NotAuthorizedError) Inject(msg string, err error) error {
	t := reflect.TypeOf(n).String()
	n.oopsError = n.oopsError.Inject(msg, t, err)
	return &n
}

type NotAuthenticatedError struct {
	oopsError
}

func (n NotAuthenticatedError) Inject(msg string, err error) error {
	t := reflect.TypeOf(n).String()
	n.oopsError = n.oopsError.Inject(msg, t, err)
	return &n
}

// Actual implementation
type oopsError struct {
	Actual  error   `json:"actual"`
	Msg     string  `json:"msg"`
	Stack   []Frame `json:"stack"`
	ErrType string  `json:"err_type"` // the outer error type, used for pretty-printing
}

func (o *oopsError) Error() string {
	output := o.Msg
	if o.Actual != nil {
		output += fmt.Sprintf("; err: %v", o.Actual)
	}
	return output
}

func (o *oopsError) Unwrap() error {
	return o.Actual
}

func (o *oopsError) Inject(msg, errType string, err error) oopsError {
	// save the original error type for printing
	o.ErrType = errType

	if len(strings.TrimSpace(msg)) > 0 {
		o.Msg = msg
	}
	if err != nil {
		o.Actual = err
	}

	_, ok := Is(err)
	if ok {
		// if we're wrapping an oops error, just set the stack
		o.Stack = getStack(err)
		return *o
	}

	// TODO: FRAMES may need to be changed, it may not go far enough back
	FRAMES := 4
	// otherwise wrap and return
	pc := make([]uintptr, 15)
	n := runtime.Callers(FRAMES, pc)
	capturedFrames := runtime.CallersFrames(pc[:n])
	keepGoing := true
	var s runtime.Frame
	for keepGoing {
		s, keepGoing = capturedFrames.Next()
		// we don't want the stack trace to include anything autogenerated protos
		if strings.HasSuffix(s.File, ".pb.go") {
			keepGoing = false
			continue
		}
		if strings.Contains(s.File, "_test.go") {
			keepGoing = false
		}
		o.Stack = append(o.Stack, Frame(s))
	}

	return *o
}

func (o *oopsError) StackTrace() []uintptr {
	var out []uintptr

	for _, f := range o.Stack[1:] {
		out = append(out, f.PC)
	}

	return out
}
